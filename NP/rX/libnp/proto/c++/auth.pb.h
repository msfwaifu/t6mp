// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto

#ifndef PROTOBUF_auth_2eproto__INCLUDED
#define PROTOBUF_auth_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_auth_2eproto();
void protobuf_AssignDesc_auth_2eproto();
void protobuf_ShutdownFile_auth_2eproto();

class AuthenticateWithKeyMessage;
class AuthenticateWithDetailsMessage;
class AuthenticateWithTokenMessage;
class AuthenticateResultMessage;
class AuthenticateUserGroupMessage;
class AuthenticateValidateTicketMessage;
class AuthenticateValidateTicketResultMessage;
class AuthenticateKickUserMessage;
class AuthenticateExternalStatusMessage;
class AuthenticateRegisterServerMessage;
class AuthenticateRegisterServerResultMessage;

// ===================================================================

class AuthenticateWithKeyMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithKeyMessage();
  virtual ~AuthenticateWithKeyMessage();

  AuthenticateWithKeyMessage(const AuthenticateWithKeyMessage& from);

  inline AuthenticateWithKeyMessage& operator=(const AuthenticateWithKeyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateWithKeyMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithKeyMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithKeyMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateWithKeyMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithKeyMessage& from);
  void MergeFrom(const AuthenticateWithKeyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string licenseKey = 1;
  inline bool has_licensekey() const;
  inline void clear_licensekey();
  static const int kLicenseKeyFieldNumber = 1;
  inline const ::std::string& licensekey() const;
  inline void set_licensekey(const ::std::string& value);
  inline void set_licensekey(const char* value);
  inline void set_licensekey(const char* value, size_t size);
  inline ::std::string* mutable_licensekey();
  inline ::std::string* release_licensekey();
  inline void set_allocated_licensekey(::std::string* licensekey);

  // @@protoc_insertion_point(class_scope:AuthenticateWithKeyMessage)
 private:
  inline void set_has_licensekey();
  inline void clear_has_licensekey();

  ::std::string* licensekey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithKeyMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateWithDetailsMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithDetailsMessage();
  virtual ~AuthenticateWithDetailsMessage();

  AuthenticateWithDetailsMessage(const AuthenticateWithDetailsMessage& from);

  inline AuthenticateWithDetailsMessage& operator=(const AuthenticateWithDetailsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateWithDetailsMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithDetailsMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithDetailsMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateWithDetailsMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithDetailsMessage& from);
  void MergeFrom(const AuthenticateWithDetailsMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:AuthenticateWithDetailsMessage)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithDetailsMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateWithTokenMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateWithTokenMessage();
  virtual ~AuthenticateWithTokenMessage();

  AuthenticateWithTokenMessage(const AuthenticateWithTokenMessage& from);

  inline AuthenticateWithTokenMessage& operator=(const AuthenticateWithTokenMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateWithTokenMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateWithTokenMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateWithTokenMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateWithTokenMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateWithTokenMessage& from);
  void MergeFrom(const AuthenticateWithTokenMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:AuthenticateWithTokenMessage)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateWithTokenMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateResultMessage();
  virtual ~AuthenticateResultMessage();

  AuthenticateResultMessage(const AuthenticateResultMessage& from);

  inline AuthenticateResultMessage& operator=(const AuthenticateResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateResultMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateResultMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateResultMessage& from);
  void MergeFrom(const AuthenticateResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required bytes sessionToken = 3;
  inline bool has_sessiontoken() const;
  inline void clear_sessiontoken();
  static const int kSessionTokenFieldNumber = 3;
  inline const ::std::string& sessiontoken() const;
  inline void set_sessiontoken(const ::std::string& value);
  inline void set_sessiontoken(const char* value);
  inline void set_sessiontoken(const void* value, size_t size);
  inline ::std::string* mutable_sessiontoken();
  inline ::std::string* release_sessiontoken();
  inline void set_allocated_sessiontoken(::std::string* sessiontoken);

  // @@protoc_insertion_point(class_scope:AuthenticateResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_sessiontoken();
  inline void clear_has_sessiontoken();

  ::google::protobuf::uint64 npid_;
  ::std::string* sessiontoken_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateResultMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateUserGroupMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateUserGroupMessage();
  virtual ~AuthenticateUserGroupMessage();

  AuthenticateUserGroupMessage(const AuthenticateUserGroupMessage& from);

  inline AuthenticateUserGroupMessage& operator=(const AuthenticateUserGroupMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateUserGroupMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateUserGroupMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateUserGroupMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateUserGroupMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateUserGroupMessage& from);
  void MergeFrom(const AuthenticateUserGroupMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 groupID = 1;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 1;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateUserGroupMessage)
 private:
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateUserGroupMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateValidateTicketMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateValidateTicketMessage();
  virtual ~AuthenticateValidateTicketMessage();

  AuthenticateValidateTicketMessage(const AuthenticateValidateTicketMessage& from);

  inline AuthenticateValidateTicketMessage& operator=(const AuthenticateValidateTicketMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateValidateTicketMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateValidateTicketMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateValidateTicketMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateValidateTicketMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateValidateTicketMessage& from);
  void MergeFrom(const AuthenticateValidateTicketMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 clientIP = 1;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientIPFieldNumber = 1;
  inline ::google::protobuf::uint32 clientip() const;
  inline void set_clientip(::google::protobuf::uint32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required bytes ticket = 3;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 3;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const void* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:AuthenticateValidateTicketMessage)
 private:
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  ::google::protobuf::uint64 npid_;
  ::std::string* ticket_;
  ::google::protobuf::uint32 clientip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateValidateTicketMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateValidateTicketResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateValidateTicketResultMessage();
  virtual ~AuthenticateValidateTicketResultMessage();

  AuthenticateValidateTicketResultMessage(const AuthenticateValidateTicketResultMessage& from);

  inline AuthenticateValidateTicketResultMessage& operator=(const AuthenticateValidateTicketResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateValidateTicketResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateValidateTicketResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateValidateTicketResultMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateValidateTicketResultMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateValidateTicketResultMessage& from);
  void MergeFrom(const AuthenticateValidateTicketResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required fixed64 npid = 2;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 2;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required int32 groupID = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 3;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateValidateTicketResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::uint64 npid_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateValidateTicketResultMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateKickUserMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateKickUserMessage();
  virtual ~AuthenticateKickUserMessage();

  AuthenticateKickUserMessage(const AuthenticateKickUserMessage& from);

  inline AuthenticateKickUserMessage& operator=(const AuthenticateKickUserMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateKickUserMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateKickUserMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateKickUserMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateKickUserMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateKickUserMessage& from);
  void MergeFrom(const AuthenticateKickUserMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 npid = 1;
  inline bool has_npid() const;
  inline void clear_npid();
  static const int kNpidFieldNumber = 1;
  inline ::google::protobuf::uint64 npid() const;
  inline void set_npid(::google::protobuf::uint64 value);

  // required int32 reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // required string reasonString = 3;
  inline bool has_reasonstring() const;
  inline void clear_reasonstring();
  static const int kReasonStringFieldNumber = 3;
  inline const ::std::string& reasonstring() const;
  inline void set_reasonstring(const ::std::string& value);
  inline void set_reasonstring(const char* value);
  inline void set_reasonstring(const char* value, size_t size);
  inline ::std::string* mutable_reasonstring();
  inline ::std::string* release_reasonstring();
  inline void set_allocated_reasonstring(::std::string* reasonstring);

  // @@protoc_insertion_point(class_scope:AuthenticateKickUserMessage)
 private:
  inline void set_has_npid();
  inline void clear_has_npid();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_reasonstring();
  inline void clear_has_reasonstring();

  ::google::protobuf::uint64 npid_;
  ::std::string* reasonstring_;
  ::google::protobuf::int32 reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateKickUserMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateExternalStatusMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateExternalStatusMessage();
  virtual ~AuthenticateExternalStatusMessage();

  AuthenticateExternalStatusMessage(const AuthenticateExternalStatusMessage& from);

  inline AuthenticateExternalStatusMessage& operator=(const AuthenticateExternalStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateExternalStatusMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateExternalStatusMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateExternalStatusMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateExternalStatusMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateExternalStatusMessage& from);
  void MergeFrom(const AuthenticateExternalStatusMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateExternalStatusMessage)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateExternalStatusMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateRegisterServerMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateRegisterServerMessage();
  virtual ~AuthenticateRegisterServerMessage();

  AuthenticateRegisterServerMessage(const AuthenticateRegisterServerMessage& from);

  inline AuthenticateRegisterServerMessage& operator=(const AuthenticateRegisterServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateRegisterServerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateRegisterServerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateRegisterServerMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateRegisterServerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateRegisterServerMessage& from);
  void MergeFrom(const AuthenticateRegisterServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string configPath = 1;
  inline bool has_configpath() const;
  inline void clear_configpath();
  static const int kConfigPathFieldNumber = 1;
  inline const ::std::string& configpath() const;
  inline void set_configpath(const ::std::string& value);
  inline void set_configpath(const char* value);
  inline void set_configpath(const char* value, size_t size);
  inline ::std::string* mutable_configpath();
  inline ::std::string* release_configpath();
  inline void set_allocated_configpath(::std::string* configpath);

  // @@protoc_insertion_point(class_scope:AuthenticateRegisterServerMessage)
 private:
  inline void set_has_configpath();
  inline void clear_has_configpath();

  ::std::string* configpath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateRegisterServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticateRegisterServerResultMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateRegisterServerResultMessage();
  virtual ~AuthenticateRegisterServerResultMessage();

  AuthenticateRegisterServerResultMessage(const AuthenticateRegisterServerResultMessage& from);

  inline AuthenticateRegisterServerResultMessage& operator=(const AuthenticateRegisterServerResultMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuthenticateRegisterServerResultMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateRegisterServerResultMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateRegisterServerResultMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateRegisterServerResultMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateRegisterServerResultMessage& from);
  void MergeFrom(const AuthenticateRegisterServerResultMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string licenseKey = 2;
  inline bool has_licensekey() const;
  inline void clear_licensekey();
  static const int kLicenseKeyFieldNumber = 2;
  inline const ::std::string& licensekey() const;
  inline void set_licensekey(const ::std::string& value);
  inline void set_licensekey(const char* value);
  inline void set_licensekey(const char* value, size_t size);
  inline ::std::string* mutable_licensekey();
  inline ::std::string* release_licensekey();
  inline void set_allocated_licensekey(::std::string* licensekey);

  // required int32 serverID = 3;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIDFieldNumber = 3;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AuthenticateRegisterServerResultMessage)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_licensekey();
  inline void clear_has_licensekey();
  inline void set_has_serverid();
  inline void clear_has_serverid();

  ::std::string* licensekey_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 serverid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_auth_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_auth_2eproto();
  #endif
  friend void protobuf_AssignDesc_auth_2eproto();
  friend void protobuf_ShutdownFile_auth_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateRegisterServerResultMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// AuthenticateWithKeyMessage

// required string licenseKey = 1;
inline bool AuthenticateWithKeyMessage::has_licensekey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithKeyMessage::set_has_licensekey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithKeyMessage::clear_has_licensekey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithKeyMessage::clear_licensekey() {
  if (licensekey_ != &::google::protobuf::internal::kEmptyString) {
    licensekey_->clear();
  }
  clear_has_licensekey();
}
inline const ::std::string& AuthenticateWithKeyMessage::licensekey() const {
  return *licensekey_;
}
inline void AuthenticateWithKeyMessage::set_licensekey(const ::std::string& value) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(value);
}
inline void AuthenticateWithKeyMessage::set_licensekey(const char* value) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(value);
}
inline void AuthenticateWithKeyMessage::set_licensekey(const char* value, size_t size) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateWithKeyMessage::mutable_licensekey() {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  return licensekey_;
}
inline ::std::string* AuthenticateWithKeyMessage::release_licensekey() {
  clear_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = licensekey_;
    licensekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateWithKeyMessage::set_allocated_licensekey(::std::string* licensekey) {
  if (licensekey_ != &::google::protobuf::internal::kEmptyString) {
    delete licensekey_;
  }
  if (licensekey) {
    set_has_licensekey();
    licensekey_ = licensekey;
  } else {
    clear_has_licensekey();
    licensekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateWithDetailsMessage

// required string username = 1;
inline bool AuthenticateWithDetailsMessage::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithDetailsMessage::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithDetailsMessage::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithDetailsMessage::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AuthenticateWithDetailsMessage::username() const {
  return *username_;
}
inline void AuthenticateWithDetailsMessage::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AuthenticateWithDetailsMessage::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AuthenticateWithDetailsMessage::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateWithDetailsMessage::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AuthenticateWithDetailsMessage::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateWithDetailsMessage::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool AuthenticateWithDetailsMessage::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateWithDetailsMessage::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateWithDetailsMessage::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateWithDetailsMessage::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AuthenticateWithDetailsMessage::password() const {
  return *password_;
}
inline void AuthenticateWithDetailsMessage::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthenticateWithDetailsMessage::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthenticateWithDetailsMessage::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateWithDetailsMessage::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AuthenticateWithDetailsMessage::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateWithDetailsMessage::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateWithTokenMessage

// required bytes token = 1;
inline bool AuthenticateWithTokenMessage::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateWithTokenMessage::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateWithTokenMessage::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateWithTokenMessage::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AuthenticateWithTokenMessage::token() const {
  return *token_;
}
inline void AuthenticateWithTokenMessage::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthenticateWithTokenMessage::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthenticateWithTokenMessage::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateWithTokenMessage::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AuthenticateWithTokenMessage::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateWithTokenMessage::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateResultMessage

// required int32 result = 1;
inline bool AuthenticateResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateResultMessage::result() const {
  return result_;
}
inline void AuthenticateResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required fixed64 npid = 2;
inline bool AuthenticateResultMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateResultMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateResultMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateResultMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateResultMessage::npid() const {
  return npid_;
}
inline void AuthenticateResultMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
}

// required bytes sessionToken = 3;
inline bool AuthenticateResultMessage::has_sessiontoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateResultMessage::set_has_sessiontoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateResultMessage::clear_has_sessiontoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateResultMessage::clear_sessiontoken() {
  if (sessiontoken_ != &::google::protobuf::internal::kEmptyString) {
    sessiontoken_->clear();
  }
  clear_has_sessiontoken();
}
inline const ::std::string& AuthenticateResultMessage::sessiontoken() const {
  return *sessiontoken_;
}
inline void AuthenticateResultMessage::set_sessiontoken(const ::std::string& value) {
  set_has_sessiontoken();
  if (sessiontoken_ == &::google::protobuf::internal::kEmptyString) {
    sessiontoken_ = new ::std::string;
  }
  sessiontoken_->assign(value);
}
inline void AuthenticateResultMessage::set_sessiontoken(const char* value) {
  set_has_sessiontoken();
  if (sessiontoken_ == &::google::protobuf::internal::kEmptyString) {
    sessiontoken_ = new ::std::string;
  }
  sessiontoken_->assign(value);
}
inline void AuthenticateResultMessage::set_sessiontoken(const void* value, size_t size) {
  set_has_sessiontoken();
  if (sessiontoken_ == &::google::protobuf::internal::kEmptyString) {
    sessiontoken_ = new ::std::string;
  }
  sessiontoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateResultMessage::mutable_sessiontoken() {
  set_has_sessiontoken();
  if (sessiontoken_ == &::google::protobuf::internal::kEmptyString) {
    sessiontoken_ = new ::std::string;
  }
  return sessiontoken_;
}
inline ::std::string* AuthenticateResultMessage::release_sessiontoken() {
  clear_has_sessiontoken();
  if (sessiontoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessiontoken_;
    sessiontoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateResultMessage::set_allocated_sessiontoken(::std::string* sessiontoken) {
  if (sessiontoken_ != &::google::protobuf::internal::kEmptyString) {
    delete sessiontoken_;
  }
  if (sessiontoken) {
    set_has_sessiontoken();
    sessiontoken_ = sessiontoken;
  } else {
    clear_has_sessiontoken();
    sessiontoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateUserGroupMessage

// required int32 groupID = 1;
inline bool AuthenticateUserGroupMessage::has_groupid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateUserGroupMessage::set_has_groupid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateUserGroupMessage::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateUserGroupMessage::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 AuthenticateUserGroupMessage::groupid() const {
  return groupid_;
}
inline void AuthenticateUserGroupMessage::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// AuthenticateValidateTicketMessage

// required fixed32 clientIP = 1;
inline bool AuthenticateValidateTicketMessage::has_clientip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_clientip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateValidateTicketMessage::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateValidateTicketMessage::clear_clientip() {
  clientip_ = 0u;
  clear_has_clientip();
}
inline ::google::protobuf::uint32 AuthenticateValidateTicketMessage::clientip() const {
  return clientip_;
}
inline void AuthenticateValidateTicketMessage::set_clientip(::google::protobuf::uint32 value) {
  set_has_clientip();
  clientip_ = value;
}

// required fixed64 npid = 2;
inline bool AuthenticateValidateTicketMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateValidateTicketMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateValidateTicketMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateValidateTicketMessage::npid() const {
  return npid_;
}
inline void AuthenticateValidateTicketMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
}

// required bytes ticket = 3;
inline bool AuthenticateValidateTicketMessage::has_ticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateValidateTicketMessage::set_has_ticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateValidateTicketMessage::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateValidateTicketMessage::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& AuthenticateValidateTicketMessage::ticket() const {
  return *ticket_;
}
inline void AuthenticateValidateTicketMessage::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void AuthenticateValidateTicketMessage::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void AuthenticateValidateTicketMessage::set_ticket(const void* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateValidateTicketMessage::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* AuthenticateValidateTicketMessage::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateValidateTicketMessage::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateValidateTicketResultMessage

// required int32 result = 1;
inline bool AuthenticateValidateTicketResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateValidateTicketResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateValidateTicketResultMessage::result() const {
  return result_;
}
inline void AuthenticateValidateTicketResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required fixed64 npid = 2;
inline bool AuthenticateValidateTicketResultMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateValidateTicketResultMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateValidateTicketResultMessage::npid() const {
  return npid_;
}
inline void AuthenticateValidateTicketResultMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
}

// required int32 groupID = 3;
inline bool AuthenticateValidateTicketResultMessage::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateValidateTicketResultMessage::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateValidateTicketResultMessage::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateValidateTicketResultMessage::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 AuthenticateValidateTicketResultMessage::groupid() const {
  return groupid_;
}
inline void AuthenticateValidateTicketResultMessage::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// AuthenticateKickUserMessage

// required fixed64 npid = 1;
inline bool AuthenticateKickUserMessage::has_npid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_npid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateKickUserMessage::clear_has_npid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateKickUserMessage::clear_npid() {
  npid_ = GOOGLE_ULONGLONG(0);
  clear_has_npid();
}
inline ::google::protobuf::uint64 AuthenticateKickUserMessage::npid() const {
  return npid_;
}
inline void AuthenticateKickUserMessage::set_npid(::google::protobuf::uint64 value) {
  set_has_npid();
  npid_ = value;
}

// required int32 reason = 2;
inline bool AuthenticateKickUserMessage::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateKickUserMessage::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateKickUserMessage::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 AuthenticateKickUserMessage::reason() const {
  return reason_;
}
inline void AuthenticateKickUserMessage::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// required string reasonString = 3;
inline bool AuthenticateKickUserMessage::has_reasonstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateKickUserMessage::set_has_reasonstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateKickUserMessage::clear_has_reasonstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateKickUserMessage::clear_reasonstring() {
  if (reasonstring_ != &::google::protobuf::internal::kEmptyString) {
    reasonstring_->clear();
  }
  clear_has_reasonstring();
}
inline const ::std::string& AuthenticateKickUserMessage::reasonstring() const {
  return *reasonstring_;
}
inline void AuthenticateKickUserMessage::set_reasonstring(const ::std::string& value) {
  set_has_reasonstring();
  if (reasonstring_ == &::google::protobuf::internal::kEmptyString) {
    reasonstring_ = new ::std::string;
  }
  reasonstring_->assign(value);
}
inline void AuthenticateKickUserMessage::set_reasonstring(const char* value) {
  set_has_reasonstring();
  if (reasonstring_ == &::google::protobuf::internal::kEmptyString) {
    reasonstring_ = new ::std::string;
  }
  reasonstring_->assign(value);
}
inline void AuthenticateKickUserMessage::set_reasonstring(const char* value, size_t size) {
  set_has_reasonstring();
  if (reasonstring_ == &::google::protobuf::internal::kEmptyString) {
    reasonstring_ = new ::std::string;
  }
  reasonstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateKickUserMessage::mutable_reasonstring() {
  set_has_reasonstring();
  if (reasonstring_ == &::google::protobuf::internal::kEmptyString) {
    reasonstring_ = new ::std::string;
  }
  return reasonstring_;
}
inline ::std::string* AuthenticateKickUserMessage::release_reasonstring() {
  clear_has_reasonstring();
  if (reasonstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reasonstring_;
    reasonstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateKickUserMessage::set_allocated_reasonstring(::std::string* reasonstring) {
  if (reasonstring_ != &::google::protobuf::internal::kEmptyString) {
    delete reasonstring_;
  }
  if (reasonstring) {
    set_has_reasonstring();
    reasonstring_ = reasonstring;
  } else {
    clear_has_reasonstring();
    reasonstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateExternalStatusMessage

// required int32 status = 1;
inline bool AuthenticateExternalStatusMessage::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateExternalStatusMessage::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateExternalStatusMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateExternalStatusMessage::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 AuthenticateExternalStatusMessage::status() const {
  return status_;
}
inline void AuthenticateExternalStatusMessage::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// AuthenticateRegisterServerMessage

// optional string configPath = 1;
inline bool AuthenticateRegisterServerMessage::has_configpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateRegisterServerMessage::set_has_configpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateRegisterServerMessage::clear_has_configpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateRegisterServerMessage::clear_configpath() {
  if (configpath_ != &::google::protobuf::internal::kEmptyString) {
    configpath_->clear();
  }
  clear_has_configpath();
}
inline const ::std::string& AuthenticateRegisterServerMessage::configpath() const {
  return *configpath_;
}
inline void AuthenticateRegisterServerMessage::set_configpath(const ::std::string& value) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(value);
}
inline void AuthenticateRegisterServerMessage::set_configpath(const char* value) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(value);
}
inline void AuthenticateRegisterServerMessage::set_configpath(const char* value, size_t size) {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  configpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateRegisterServerMessage::mutable_configpath() {
  set_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    configpath_ = new ::std::string;
  }
  return configpath_;
}
inline ::std::string* AuthenticateRegisterServerMessage::release_configpath() {
  clear_has_configpath();
  if (configpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configpath_;
    configpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateRegisterServerMessage::set_allocated_configpath(::std::string* configpath) {
  if (configpath_ != &::google::protobuf::internal::kEmptyString) {
    delete configpath_;
  }
  if (configpath) {
    set_has_configpath();
    configpath_ = configpath;
  } else {
    clear_has_configpath();
    configpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AuthenticateRegisterServerResultMessage

// required int32 result = 1;
inline bool AuthenticateRegisterServerResultMessage::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateRegisterServerResultMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AuthenticateRegisterServerResultMessage::result() const {
  return result_;
}
inline void AuthenticateRegisterServerResultMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string licenseKey = 2;
inline bool AuthenticateRegisterServerResultMessage::has_licensekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_licensekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_licensekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticateRegisterServerResultMessage::clear_licensekey() {
  if (licensekey_ != &::google::protobuf::internal::kEmptyString) {
    licensekey_->clear();
  }
  clear_has_licensekey();
}
inline const ::std::string& AuthenticateRegisterServerResultMessage::licensekey() const {
  return *licensekey_;
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const ::std::string& value) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(value);
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const char* value) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(value);
}
inline void AuthenticateRegisterServerResultMessage::set_licensekey(const char* value, size_t size) {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  licensekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateRegisterServerResultMessage::mutable_licensekey() {
  set_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    licensekey_ = new ::std::string;
  }
  return licensekey_;
}
inline ::std::string* AuthenticateRegisterServerResultMessage::release_licensekey() {
  clear_has_licensekey();
  if (licensekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = licensekey_;
    licensekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthenticateRegisterServerResultMessage::set_allocated_licensekey(::std::string* licensekey) {
  if (licensekey_ != &::google::protobuf::internal::kEmptyString) {
    delete licensekey_;
  }
  if (licensekey) {
    set_has_licensekey();
    licensekey_ = licensekey;
  } else {
    clear_has_licensekey();
    licensekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 serverID = 3;
inline bool AuthenticateRegisterServerResultMessage::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticateRegisterServerResultMessage::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticateRegisterServerResultMessage::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticateRegisterServerResultMessage::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 AuthenticateRegisterServerResultMessage::serverid() const {
  return serverid_;
}
inline void AuthenticateRegisterServerResultMessage::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_auth_2eproto__INCLUDED
